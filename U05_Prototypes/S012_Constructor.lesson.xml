<?xml version='1.0' encoding='UTF-8'?>
<slide xmlns="https://ulearn.me/schema/v2" title="Функция-конструктор" id="2bba3f2d-891d-4b0a-a950-92b8961886ce">
  <markdown>
    Из предыдущих примеров видно, что при создании объектов стоит использовать две сущности:

    - Функция-конструктор, которая будет заполнять все собственные свойства объекта
    - Объект-прототип, в котором будут храниться все методы объекта

    Создание объектов — операция частая, поэтому в JS сразу был добавлен удобный способ определения функции-конструктора с прототипом.
    Основная идея: если вызвать функцию с ключевым словом `new`, то все будет работать несколько иначе.

    <code language="javascript">
      // По соглашению функции, которые используются с new,
      // именуются с большой буквы, а имя обозначает создаваемую сущность
      function Point(x, y) {
        // При вызове с new в this неявным образом кладется объект,
        // у которого объект Point.prototype задан в качестве прототипа
        this.x = x;
        this.y = y;
        // Если ничего не возвращать при вызове с new,
        // в качестве результата вернется this
      }

      // У каждой функции в свойстве prototype хранится некоторый объект.
      // Чтобы добавить методы объектам,
      // которые будет создавать функция при вызове с new,
      // нужно их добавить в прототип, в данном случае `Point.prototype`.
      Point.prototype.getLength = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      };

      const p1 = new Point(1, 2);
      const p2 = new Point(2, 3);
      // Одна и та же функция из прототипа вызывается для разных объектов.
      const l1 = p1.getLength();
      const l2 = p2.getLength();
    </code>

    Связь объекта-прототипа и функции-конструктора взаимна, если ее не ломать:

    - Прототип хранится в свойстве `prototype` функции
    - Функция хранится в свойстве `constructor` прототипа
  </markdown>
</slide>
