<?xml version='1.0' encoding='UTF-8'?>
<slide xmlns="https://ulearn.me/schema/v2" title="Наследование" id="8b449566-d124-4759-a60e-25a4321f26f4">
  <markdown>
    От наследование обычно ожидают:

    1. свойства родителя определены в потомках
    2. методы родителя определены в потомках
    3. возможность переопределять методы
    4. полиморфизм: возможность использовать объекты типов-наследников там, где ожидается объект типа-родителя

    В JS используется утиная типизация: в функцию можно передать объект любого типа и скорее всего она отработает корректно, если в объекте есть нужные свойства.
    Поэтому в JS из 1 и 2 следует 4.

    Наследование методов организовать просто: надо связать прототипы и тогда все методы базового класса будут доступны в наследнике.
    Наследование свойств организовать сложнее: надо не забыть в конструкторе наследника вызвать конструктор родителя, автоматически это не произойдет.
    Переопределение методов выглядит совсем коряво: полностью перекрыть метод легко, а вот использовать в новом методе версию из родителя непросто.

    <code language="javascript">
      function Duck(name) {
        this.name = name;
      }
      Duck.prototype.fly = function() {
        console.log(`${this.name} flies away...`);
      };
      Duck.prototype.quack = function() {
        console.log(`${this.name} quacks!`);
      };

      const GizmoDuck = function(name) {
        // В объекте GizmoDuck будут созданы все свойства Duck
        // благодаря вызову конструктора.
        Duck.call(this, name);
        this.superPower = true;
        this.useLaser = () => {
          console.log('whp...whp...');
        };
      };
      // В объекте GizmoDuck будут доступны все методы Duck
      // благодаря связи прототипов.
      Object.setPrototypeOf(GizmoDuck.prototype, Duck.prototype);

      GizmoDuck.prototype.fly = function() {
        // Приходится явно указывать где лежит прототип
        // и у него вызывать переопределенный метод.
        Duck.prototype.fly.call(this);
        console.log('with super speed!');
      };

      const donald = new Duck('Donald');
      const launchpad = new GizmoDuck('Launchpad');
    </code>

    Вывод. Механизм прототипов позволяет организовать наследование в JS. Но придется писать много лишних слов.
    Корявость такого способа подтверждают тысячи библиотек на JS, которые пытались сделать наследование более лаконичным.
    Наконец появился краткий синтаксис определения типов и наследования — классы. Но об этом позже.
  </markdown>
</slide>
