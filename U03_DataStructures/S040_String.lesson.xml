<?xml version="1.0"?>
<slide id="32ec8bcd-30c1-407b-b50c-9ce44cd2cc49" title="Строки" xmlns="https://ulearn.me/schema/v2">
  <markdown>
В JavaScript любые текстовые данные являются строками. Не существует 
отдельного типа «символ», который есть в ряде других языков.

Внутренний формат для строк — всегда [UTF-16](https://ru.wikipedia.org/wiki/UTF-16), вне зависимости от кодировки страницы.

## Кавычки

В JavaScript есть разные типы кавычек.

Строку можно создать с помощью одинарных, двойных либо обратных кавычек:

<code>
let single = 'single-quoted';
let double = "double-quoted";

let backticks = `backticks`;
</code>

Одинарные и двойные кавычки работают, по сути, одинаково,
 а если использовать обратные кавычки, то в такую строку мы сможем 
вставлять произвольные выражения, обернув их в `${…}`:

<code>
function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
</code>

Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:

<code>
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // список гостей, состоящий из нескольких строк
</code>

Выглядит вполне естественно, не правда ли? Что тут 
такого? Но если попытаться использовать точно так же одинарные или 
двойные кавычки, то будет ошибка:

<code>
let guestList = "Guests: // Error: Unexpected token ILLEGAL
  * John";
</code>

Одинарные и двойные кавычки в языке с незапамятных 
времён: тогда потребность в многострочных строках не учитывалась. Что 
касается обратных кавычек, они появились существенно позже, и поэтому 
они гибче.

Обратные кавычки также позволяют задавать «шаблонную функцию» перед первой обратной кавычкой. Используемый синтаксис: `func`string``. Автоматически вызываемая функция `func` получает строку и встроенные в неё выражения и может их обработать. Подробнее об этом можно прочитать в [документации](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/template_strings#%D0%A2%D0%B5%D0%B3%D0%BE%D0%B2%D1%8B%D0%B5_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B).
 Если перед строкой есть выражение, то шаблонная строка называется 
«теговым шаблоном». Это позволяет использовать свою шаблонизацию для 
строк, но на практике теговые шаблоны применяются редко.

## Спецсимволы

Многострочные
 строки также можно создавать с помощью одинарных и двойных кавычек, 
используя так называемый «символ перевода строки», который записывается 
как `\n`:

<code>
let guestList = "Guests:\n * John\n * Pete\n * Mary";

alert(guestList); // список гостей, состоящий из нескольких строк
</code>

В частности, эти две строки эквивалентны, просто записаны по-разному:

<code>
// перевод строки добавлен с помощью символа перевода строки
let str1 = "Hello\nWorld";

// многострочная строка, созданная с использованием обратных кавычек
let str2 = `Hello
World`;

alert(str1 == str2); // true
</code>

Все спецсимволы начинаются с обратного слеша, `\` — так называемого «символа экранирования».

Он также используется, если необходимо вставить в строку кавычку.

К примеру:

<code>
alert( 'I*\'*m the Walrus!' ); // *I'm* the Walrus!
</code>

Здесь перед входящей в строку кавычкой необходимо добавить обратный слеш — `\'` — иначе она бы обозначала окончание строки.

Разумеется, требование экранировать относится только к таким же 
кавычкам, как те, в которые заключена строка. Так что мы можем применить
 и более элегантное решение, использовав для этой строки двойные или 
обратные кавычки:

<code>
alert( `I'm the Walrus!` ); // I'm the Walrus!
</code>

Заметим, что обратный слеш `\` служит лишь для
 корректного прочтения строки интерпретатором, но он не записывается в 
строку после её прочтения. Когда строка сохраняется в оперативную 
память, в неё не добавляется символ `\`. Вы можете явно видеть это в выводах `alert` в примерах выше.

Но что, если нам надо добавить в строку собственно сам обратный слеш `\`?

Это можно сделать, добавив перед ним… ещё один обратный слеш!

<code>
alert( `The backslash: \\` ); // The backslash: \
</code>

## Длина строки

Свойство `length` содержит длину строки:

<code>
alert( `My\n`.length ); // 3
</code>

Обратите внимание, `\n` — это один спецсимвол, поэтому тут всё правильно: длина строки `3`.

`length` — это свойство

Бывает так, что люди с практикой в других языках случайно пытаются вызвать его, добавляя круглые скобки: они пишут `str.length()` вместо `str.length`. Это не работает.

Так как `str.length` — это числовое свойство, а не функция, добавлять скобки не нужно.

## Доступ к символам

Получить символ, который занимает позицию `pos`, можно с помощью квадратных скобок: `[pos]`. Также можно использовать метод `charAt`: [str.charAt(pos)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/charAt). Первый символ занимает нулевую позицию:

<code>
let str = `Hello`;

// получаем первый символ
alert( str[0] ); // H
alert( str.charAt(0) ); // H

// получаем последний символ
alert( str[str.length - 1] ); // o
</code>

Квадратные скобки — современный способ получить символ, в то время как `charAt` существует в основном по историческим причинам.

Разница только в том, что если символ с такой позицией отсутствует, тогда `[]` вернёт `undefined`, а `charAt` — пустую строку:

<code>
let str = `Hello`;

alert( str[1000] ); // undefined
alert( str.charAt(1000) ); // '' (пустая строка)
</code>

Также можно перебрать строку посимвольно, используя `for..of`:

<code>
for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.)
}
</code>

## Строки неизменяемы

Содержимое
 строки в JavaScript нельзя изменить. Нельзя взять символ посередине и 
заменить его. Как только строка создана — она такая навсегда.

Давайте попробуем так сделать, и убедимся, что это не работает:

<code>
let str = 'Hi';

str[0] = 'h'; // ошибка
alert( str[0] ); // не работает
</code>

Можно создать новую строку и записать её в ту же самую переменную вместо старой.

Например:

<code>
let str = 'Hi';

str = 'h' + str[1]; // заменяем строку

alert( str ); // hi
</code>

В последующих разделах мы увидим больше примеров.

## Изменение регистра

Методы [toLowerCase()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase) и [toUpperCase()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase) меняют регистр символов:

<code>
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
</code>

Если мы захотим перевести в нижний регистр какой-то конкретный символ:

<code>
alert( 'Interface'[0].toLowerCase() ); // 'i'
</code>

## Поиск подстроки

Существует несколько способов поиска подстроки.

### [str.indexOf](https://learn.javascript.ru/string#str-indexof)

Первый метод — [str.indexOf(substr, pos)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf).

Он ищет подстроку `substr` в строке `str`, начиная с позиции `pos`, и возвращает позицию, на которой располагается совпадение, либо `-1` при отсутствии совпадений.

Например:

<code>
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру

alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)
</code>

Необязательный второй аргумент позволяет начать поиск с определённой позиции.

Например, первое вхождение `"id"` — на позиции `1`. Для того, чтобы найти следующее, начнём поиск с позиции `2`:

<code>
let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
</code>

Чтобы найти все вхождения подстроки, нужно запустить `indexOf` в цикле. Каждый раз, получив очередную позицию, начинаем новый поиск со следующей:

<code>
let str = 'Ослик Иа-Иа посмотрел на виадук';

let target = 'Иа'; // цель поиска

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Найдено тут: ${foundPos}` );
  pos = foundPos + 1; // продолжаем со следующей позиции
}
</code>

Тот же алгоритм можно записать и короче:

<code>
let str = "Ослик Иа-Иа посмотрел на виадук";
let target = "Иа";

*let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}*
</code>

`str.lastIndexOf(substr, position)`

Также есть похожий метод [str.lastIndexOf(substr, position)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf), который ищет с конца строки к её началу.

Он используется тогда, когда нужно получить самое последнее 
вхождение: перед концом строки или начинающееся до (включительно) 
определённой позиции.

При проверке `indexOf` в условии `if` есть небольшое неудобство. Такое условие не будет работать:

<code>
let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert("Совпадение есть"); // не работает
}
</code>

Мы ищем подстроку `"Widget"`, и она здесь есть, прямо на позиции `0`. Но `alert` не показывается, т. к. `str.indexOf("Widget")` возвращает `0`, и `if` решает, что тест не пройден.

Поэтому надо делать проверку на `-1`:

<code>
let str = "Widget with id";

*if (str.indexOf("Widget") != -1) {*alert("Совпадение есть"); // теперь работает
}
</code>

### Трюк с побитовым НЕ

Существует старый трюк с использованием [побитового оператора НЕ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT) — `~`.
 Он преобразует число в 32-разрядное целое со знаком (signed 32-bit 
integer). Дробная часть, в случае, если она присутствует, отбрасывается.
 Затем все биты числа инвертируются.

На практике это означает простую вещь: для 32-разрядных целых чисел значение `~n` равно `-(n+1)`.

В частности:

<code>
alert( ~2 ); // -3, то же, что -(2+1)
alert( ~1 ); // -2, то же, что -(1+1)
alert( ~0 ); // -1, то же, что -(0+1)
*alert( ~-1 ); // 0, то же, что -(-1+1)*
</code>

Таким образом, `~n` равняется 0 только при `n == -1` (для любого `n`, входящего в 32-разрядные целые числа со знаком).

Соответственно, прохождение проверки `if ( ~str.indexOf("…") )` означает, что результат `indexOf` отличен от `-1`, совпадение есть.

Это иногда применяют, чтобы сделать проверку `indexOf` компактнее:

<code>
let str = "Widget";

if (~str.indexOf("Widget")) {
  alert( 'Совпадение есть' ); // работает
}
</code>

Обычно использовать возможности языка каким-либо 
неочевидным образом не рекомендуется, но этот трюк широко используется в
 старом коде, поэтому его важно понимать.

Просто запомните: `if (~str.indexOf(…))` означает «если найдено».

Впрочем, если быть точнее, из-за того, что большие числа обрезаются до 32 битов оператором `~`, существуют другие числа, для которых результат тоже будет `0`, самое маленькое из которых — `~4294967295=0`. Поэтому такая проверка будет правильно работать только для строк меньшей длины.

На данный момент такой трюк можно встретить только в старом коде, потому что в новом он просто не нужен: есть метод `.includes` (см. ниже).

### includes, startsWith, endsWith

Более современный метод [str.includes(substr, pos)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/includes) возвращает `true`, если в строке `str` есть подстрока `substr`, либо `false`, если нет.

Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна:

<code>
alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
</code>

Необязательный второй аргумент `str.includes` позволяет начать поиск с определённой позиции:

<code>
alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
</code>

Методы [str.startsWith](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) и [str.endsWith](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith) проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

<code>
alert( "*Wid*get".startsWith("Wid") ); // true, "Wid" — начало "Widget"
alert( "Wid*get*".endsWith("get") ); // true, "get" — окончание "Widget"
</code>

## Получение подстроки

В JavaScript есть 3 метода для получения подстроки: `substring`, `substr` и `slice`.

`str.slice(start [, end])`Возвращает часть строки от `start` до (не включая) `end`.
Например:
        
        

<code>
let str = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
alert( str.slice(0, 5) );
// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
alert( str.slice(0, 1) );
</code>

Если аргумент `end` отсутствует, `slice` возвращает символы до конца строки:

<code>
let str = "st*ringify*";
alert( str.slice(2) ); // ringify, с позиции 2 и до конца
</code>

Также для `start/end` можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов *с конца строки*:

<code>
let str = "strin*gif*y";

// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
alert( str.slice(-4, -1) ); // gif
</code>

`str.substring(start [, end])`

Возвращает часть строки *между* `start` и `end` (не включая) `end`.
Это — почти то же, что и `slice`, но можно задавать `start` больше `end`.
Если `start` больше `end`, то метод `substring` сработает так, как если бы аргументы были поменяны местами.
Например:

<code>
let str = "st*ring*ify";

// для substring эти два примера — одинаковы
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// …но не для slice:
alert( str.slice(2, 6) ); // "ring" (то же самое)
alert( str.slice(6, 2) ); // "" (пустая строка)
      
      
Отрицательные значения substring, в отличие от slice, не поддерживает, они интерпретируются как 0.
</code>

`str.substr(start [, length])`

Возвращает часть строки от `start` длины `length`.
В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:      

<code>
let str = "st*ring*ify";
// ring, получаем 4 символа, начиная с позиции 2
alert( str.substr(2, 4) );
</code>

Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

<code>
let str = "stringify";
// gi, получаем 2 символа, начиная с позиции 4 с конца строки
alert( str.substr(-4, 2) );
</code>

## Сравнение строк

Как мы знаем из главы [Операторы сравнения](https://learn.javascript.ru/comparison), строки сравниваются посимвольно в алфавитном порядке.

Тем не менее, есть некоторые нюансы.

1. Строчные буквы больше заглавных:
- `alert( 'a' &gt; 'Z' ); // true`
- Буквы, имеющие диакритические знаки, идут «не по порядку»:
1. `alert( 'Österreich' &gt; 'Zealand' ); // true`
    
    Это может привести к своеобразным результатам при сортировке названий стран: нормально было бы ожидать, что `Zealand` будет после `Österreich` в списке.
    

Чтобы разобраться, что происходит, давайте ознакомимся с внутренним представлением строк в JavaScript.

Строки кодируются в [UTF-16](https://ru.wikipedia.org/wiki/UTF-16).
 Таким образом, у любого символа есть соответствующий код. Есть 
специальные методы, позволяющие получить символ по его коду и наоборот.

`str.codePointAt(pos)`Возвращает код для символа, находящегося на позиции `pos`: 

<code>
// одна и та же буква в нижнем и верхнем регистре
// будет иметь разные коды
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90
</code>

`String.fromCodePoint(code)`

Создаёт символ по его коду `code`      

<code>
alert( String.fromCodePoint(90) ); // Z
</code>

Также можно добавлять Юникодные символы по их кодам, используя `\u` с шестнадцатеричным кодом символа:

<code>
// 90 — 5a в шестнадцатеричной системе счисления
alert( '\u005a' ); // Z
</code>

Давайте сделаем строку, содержащую символы с кодами от `65` до `220` — это латиница и ещё некоторые распространённые символы:

<code>
let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
</code>

Как видите, сначала идут заглавные буквы, затем несколько спецсимволов, затем строчные и `Ö` ближе к концу вывода.

Теперь очевидно, почему `a &gt; Z`.

Символы сравниваются по их кодам. Больший код — больший символ. Код `a` (97) больше кода `Z` (90).

- Все строчные буквы идут после заглавных, так как их коды больше.
- Некоторые буквы, такие как `Ö`, вообще находятся вне основного алфавита. У этой буквы код больше, чем у любой буквы от `a` до `z`.

### Правильное сравнение

«Правильный» алгоритм сравнения строк сложнее, чем может показаться, так как разные языки используют разные алфавиты.

Поэтому браузеру нужно знать, какой язык использовать для сравнения.

К счастью, все современные браузеры (для IE10− нужна дополнительная библиотека [Intl.JS](https://github.com/andyearnshaw/Intl.js/)) поддерживают стандарт [ECMA 402](https://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf), обеспечивающий правильное сравнение строк на разных языках с учётом их правил.

Для этого есть соответствующий метод.

Вызов [str.localeCompare(str2)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare) возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:

- Отрицательное число, если `str` меньше `str2`.
- Положительное число, если `str` больше `str2`.
- `0`, если строки равны.

Например:

<code>
alert( 'Österreich'.localeCompare('Zealand') ); // -1
</code>

У этого метода есть два дополнительных аргумента, которые указаны в [документации](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
 Первый позволяет указать язык (по умолчанию берётся из окружения) — от 
него зависит порядок букв. Второй — определить дополнительные правила, 
такие как чувствительность к регистру, а также следует ли учитывать 
различия между `"a"` и `"á"`.

### [Суррогатные пары](https://learn.javascript.ru/string#surrogatnye-pary)

Все часто используемые символы имеют 2-байтовые коды. Буквы в большинстве 
европейских языков, цифры и даже большинство иероглифов имеют 2-байтовое
представление.

Но 2 байта допускают только 65536 комбинаций, так что на все символы 
этого, разумеется, не хватит. Поэтому редкие символы кодируются парой 
2-байтовых символов, также называемые «суррогатной парой».

Длина таких символов равна `2`:

<code>
alert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X
alert( '😂'.length ); // 2, FACE WITH TEARS OF JOY
alert( '𩷶'.length ); // 2, редкий китайский иероглиф
</code>

Обратите внимание, суррогатные пары не существовали, когда был создан JavaScript, поэтому язык не обрабатывает их адекватно!

Ведь в каждой из этих строк только один символ, а `length` показывает длину `2`.

`String.fromCodePoint` и `str.codePointAt` — два редких метода, правильно работающие с суррогатными парами, но они и появились в языке недавно. До них были только [String.fromCharCode](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode) и [str.charCodeAt](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt). Эти методы, вообще, делают то же самое, что `fromCodePoint/codePointAt`, но не работают с суррогатными парами.

Получить символ, представленный суррогатной парой, может быть не так 
просто, потому что суррогатная пара интерпретируется как два символа:

<code>
alert( '𝒳'[0] ); // странные символы...
alert( '𝒳'[1] ); // ...части суррогатной пары
</code>

Части суррогатной пары не имеют смысла сами по себе, так что вызовы `alert` в этом примере покажут лишь мусор.

Технически, суррогатные пары возможно обнаружить по их кодам: если код символа находится в диапазоне `0xd800..0xdbff`, то это — первая часть суррогатной пары. Следующий символ — вторая часть — имеет код в диапазоне `0xdc00..0xdfff`. Эти два диапазона выделены исключительно для суррогатных пар по стандарту.

В данном случае:

<code>
// charCodeAt не поддерживает суррогатные пары, поэтому возвращает код для их частей

alert( '𝒳'.charCodeAt(0).toString(16) ); // d835, между 0xd800 и 0xdbff
alert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3, между 0xdc00 и 0xdfff
</code>

Дальше в главе [Перебираемые объекты](https://learn.javascript.ru/iterable)
 будут ещё способы работы с суррогатными парами. Для этого есть и 
специальные библиотеки, но нет достаточно широко известной, чтобы 
предложить её здесь.

### Диакритические знаки и нормализация

Во многих языках есть символы, состоящие из некоторого основного символа со знаком сверху или снизу.

Например, буква `a` — это основа для `àáâäãåā`.
 Наиболее используемые составные символы имеют свой собственный код в 
таблице UTF-16. Но не все, в силу большого количества комбинаций.

Чтобы поддерживать любые комбинации, UTF-16 позволяет использовать 
несколько Юникодных символов: основной и дальше один или несколько 
особых символов-знаков.

Например, если после `S` добавить специальный символ «точка сверху» (код `\u0307`), он отобразится как Ṡ.

<code>
alert( 'S\u0307' ); // Ṡ
</code>

Если надо добавить сверху (или снизу) ещё один знак — без проблем, просто добавляем соответствующий символ.

Например, если добавить символ «точка снизу» (код `\u0323`), отобразится S с точками сверху и снизу: `Ṩ`.

Добавляем два символа:

<code>
alert( 'S\u0307\u0323' ); // Ṩ
</code>

Это даёт большую гибкость, но из-за того, что порядок 
дополнительных символов может быть различным, мы получаем проблему 
сравнения символов: можно представить по-разному символы, которые ничем 
визуально не отличаются.

Например:

<code>
let s1 = 'S\u0307\u0323'; // Ṩ, S + точка сверху + точка снизу
let s2 = 'S\u0323\u0307'; // Ṩ, S + точка снизу + точка сверху

alert( `s1: ${s1}, s2: ${s2}` );

alert( s1 == s2 ); // false, хотя на вид символы одинаковы (?!)
</code>

Для решения этой проблемы есть алгоритм «Юникодной нормализации», приводящий каждую строку к единому «нормальному» виду.

Его реализует метод [str.normalize()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/normalize).

<code>
alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true
</code>

Забавно, но в нашем случае `normalize()` «схлопывает» последовательность из трёх символов в один: `\u1e68` — S с двумя точками.

<code>
alert( "S\u0307\u0323".normalize().length ); // 1

alert( "S\u0307\u0323".normalize() == "\u1e68" ); // true
</code>

Разумеется, так происходит не всегда. Просто Ṩ — это 
достаточно часто используемый символ, поэтому создатели UTF-16 включили 
его в основную таблицу и присвоили ему код.

Подробнее о правилах нормализации и составлении символов можно прочитать в дополнении к стандарту Юникод: [Unicode Normalization Forms](http://www.unicode.org/reports/tr15/). Для большинства практических целей информации из этого раздела достаточно.
  </markdown>
</slide>