<?xml version='1.0' encoding='UTF-8'?>
<slide.exercise xmlns="https://ulearn.me/schema/v2" title="Задание. Анимастер" id="808cd421-2e1b-4221-8757-2220c411f1c2">
    <scoring group="exercise" passedTestsScore="10" codeReviewScore="40"/>
    <markdown>
        Мы будем делать код для "`Анимастера`". Это скрипт, позволяющий создавать и управлять анимациями.
        При клике на кнопку play возле названия анимации запустят ее.
        При клике на кнопку stop анимация должна остановиться
        При клике на кнопку reset анимация должна перезагрузиться

        Для решения данной задачи тебе нужно дописать все дополнительные функции для анимастера, кроме `getTransform`
        Мы уже написали все необходимые методы, менять сигнатуру этих методов не нужно, тебе лишь нужно дописать работу функций (дописать все, где есть `TODO`)

        Заметь - функция `getTransform` служебная, и мы её уже написали за тебя. Она отвечает за значение свойство
        [transform](https://developer.mozilla.org/ru/docs/Web/CSS/transform)

        ####Посмотри, как реализована функция `fadeIn`:

        - К текущему объекту добавляется функция `addFadeIn`, которая принимает в себя длительность анимации (`duration`)
        - Далее в текущем объекте ко свойству `this._steps` добавляется объект с названием анимации (`fadeIn:true`)  и длительностью а затем мы возвращаем текущий объект, из которого вызываем функцию `play` элементом, который анимируем (`element`)

        Однако сейчас, при нажатии на кнопку play  у анимации `fadeIn` мы ничего не увидим, так как фуункция playSteps не реализована

        ####Что она должна делать ?

         - Функция `playSteps`, в соответствии с комментариями, должна обрабатывать все шаги анимации, в то время как `playStep` - вложенная функция обрабатывает лишь отдельный шаг от анимации из массива `this._steps`
         - Функия `setTimeout` в асинхронном режиме запускает `playStep`. Её также менять не нужно, однако обрати внимание на второй параметр функции `setTimeout` и `TODO` : длительность задержки (в мс), если она необходима. Иначе `0`
         - Переменная `stopped` отвечает за отстановку анимации. Она тебе пригодиться для остановки сложных анимаций, о них далее
         - Переменная `restSteps`: в нее нужно копировать шаги из `this._steps`, дабы не взаимодействовать с самим объектом из `this`.
         - Переменная `resetActions` представляет собой объект, в который нужно добавлять по названию анимации функцию перезагрузки этой анимации (например `resetFadeIn`)
         - Переменная `counter`: отвечает за кол-во потовров анимации, если она циклична. С ней никаких манипуляций производить не нужно.

        ####Функция `playStep` должна уметь следующее:

        - изменять css свойство `transfrom` через функцию `getTransform` на каждом шаге анимации
        - изменять css свойство `transitionDuration`, если у данного шага анимации есть задержка (`duration`). Иначе делать это поле `null`
        - в зависимости от анимации, (`fadeIn` или `fadeOut`) должна манипулировать классами `hide` и `show` у данного `element`. Здесь тебе пригодиться свойство [classList](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)
        - добавлять в `resetAction` необходимую функцию перезагрузки

        ####Функция `playSteps` - её вывод недописан, ибо не реализованы функции `stop` и `reset`

        - Функция `stop()` должна останавливать анимацию. Для этого у нас есть переменная `stopped`
        - Функция `reset()` должна перезагружать анимации. Для эотого у нас есть переменная `resetActions`. Подумай, как это реализовать)

        Если ты правильно написал функцию `playSteps`, то анимация `fadeIn` заработает.
        И по аналогии с `fadeIn`, тебе необходимо реализовать следующие анимации:

        `fadeOut` - Функция плавно переводит элемент в прозрачный.

        `move` - Функция передвигающая элемент. Здесь тебе поможет значение `translation`

        `scale` - Функция увеличивающая/уменьшающая элемент. Здесь тебе поможет значение `ratio`

        Для каждой из этих анимаций необходима функция перезагрузки (`reset`).
        Сигнатура функций перезагрузки, также уже написана, нужно лишь их реализовать

        Помимо этого, тебе необходимо реализовать 3 сложных анимации:

        ####`moveAndHide`

        1. Элемент передвигается на `100px` по `x` и `20px` по `y` с длительностью `duration * 2/5`
        2. Элемент гаснет с длительностью равной `duration * 3/5`

        ####`showAndHide`

        1. Элемент должен появиться с длительностью равной `duration * 1/3`
        2. Происходит пауза длительностью `duration * 1/3`
        3. Элемент должен погаснуть с длительностью равной `duration * 1/3`

        ####`HeartBeating`

        1. элемент должен увеличиться в размерах на `1.4` в течение `0.5` секунды
        2. Элемент возвращаеться в исходное состояние с той же длительностью
        3. Обрати внимание, эта анимация должна быть циклична (повторяться несколько раз)


<!--        1. Функция animaster должна возвращать объект с методами для запуска разных анимаций.-->
<!--        Сделай так, чтобы кнопки на страничке все еще показывали анимацию.-->
<!--        Использовать анимации теперь можно будет вот так:-->

<!--        animaster().fadeIn(element, 500)-->



<!--        Функция fadeIn возвращает результат работы функции play-->

<!--        2. По аналогии с функцией fadeIn создай функцию  fadeOut, скрывающую элемент.-->

<!--        3. Создай функцию move, которая принимает в в себя-->
<!--            - element — HTMLElement, который надо анимировать-->
<!--            - duration — Продолжительность анимации в миллисекундах-->
<!--            - translation — объект с полями x и y, обозначающими смещение блока-->

<!--&lt;!&ndash;        3. Мы хотим, немного облегчить жизнь пользователям анимастера, поэтому напишем для них несколько сложных анимаций.&ndash;&gt;-->
<!--&lt;!&ndash;        Сложные анимации состоят из нескольких простых, запущенных в правильном порядке и в нужное время.&ndash;&gt;-->
<!--&lt;!&ndash;        Добавь в интерфейс анимастера три новые анимации. Не забудь сделать так, чтобы с html-странички можно было их запустить.&ndash;&gt;-->
<!--&lt;!&ndash;        Вот такие анимации должен реализовывать анимастер:&ndash;&gt;-->
<!--&lt;!&ndash;        - moveAndHide - блок должен одновременно сдвигаться на 100 пикселей вправо и на 20 вниз, а потом исчезать.&ndash;&gt;-->
<!--&lt;!&ndash;        Метод на вход должен принимать продолжительность анимации. При этом 2/5 времени блок двигается, 3/5 — исчезает.&ndash;&gt;-->
<!--&lt;!&ndash;        - showAndHide — блок должен появиться, подождать и исчезнуть. Каждый шаг анимации длится 1/3 от времени,&ndash;&gt;-->
<!--&lt;!&ndash;        переданного аргументом в функцию.&ndash;&gt;-->
<!--&lt;!&ndash;        - heartBeating — имитация сердцебиения. Сначала элемент должен увеличиться в 1,4 раза, потом обратно к 1.&ndash;&gt;-->
<!--&lt;!&ndash;        Каждый шаг анимации занимает 0,5 секунды. Анимация должна повторяться бесконечно.&ndash;&gt;-->

<!--&lt;!&ndash;        4. Сделай возможность отключать анимацию сердцебиения:&ndash;&gt;-->
<!--&lt;!&ndash;        - сделай, чтобы метод heartBeating возвращал объект с методом stop&ndash;&gt;-->
<!--&lt;!&ndash;        - при вызове метода stop анимация должна прекращаться (скорее всего, нужно останавливать таймер, которым ты&ndash;&gt;-->
<!--&lt;!&ndash;        анимацию запускаешь)&ndash;&gt;-->
<!--&lt;!&ndash;        - добавь в разметку кнопку "stop" по аналогии с кнопкой play&ndash;&gt;-->
<!--&lt;!&ndash;        - в коде добавь обработчик клика по аналогии с тем, как это сделано для кнопки play.&ndash;&gt;-->
<!--&lt;!&ndash;        Обработчик должен вызывать метод stop анимации&ndash;&gt;-->

<!--        5. Сделай функции отмены для каждой элементарной операции.-->
<!--        Создай функции resetFadeIn, resetFadeOut и resetMoveAndScale-->
<!--        Все эти функции принимают на вход элемент, на котором надо сбросить состояние.-->
<!--        - resetFadeIn и resetFadeOut должны менять обратно css-классы в classList-->
<!--        - каждая из них должны убирать все дописанные стили, устанавливая их в null:-->

<!--        element.style.заданныйАнимациейСтиль = null;-->

<!--&lt;!&ndash;        6. Сделай кнопку reset для анимации moveAndHide по аналогии с кнопкой stop из одного из предыдущих пунктов.&ndash;&gt;-->
<!--&lt;!&ndash;        При нажатии на кнопку reset последующие шаги анимации должны отменяться аналогично stop из heartBeating,&ndash;&gt;-->
<!--&lt;!&ndash;        а элемент должен мгновенно вернуться в исходное состояние с помощью функций из предыдущего пункта.&ndash;&gt;-->

<!--        7. Сделай так, чтобы анимацию move можно было вызвать не только так:-->

<!--        animaster().move(element, 500, {x: 20, y: 20});-->

<!--        Но и так:-->

<!--        animaster().addMove(500, {x: 20, y:20}).play(element);-->

<!--        Для этого:-->
<!--        - добавь методы addMove и play в объект, возвращаемый функцией animaster-->
<!--        - в объекте, возвращаемом из анимастера, должно появиться поле _steps — массив шагов анимации (в начале пустой).-->
<!--        Поле _steps — приватное. Приватные поля по договоренности между разработчиками начинаются с нижнего подчеркивания.-->
<!--        - метод addMove должен возвращать this (то есть тот объект анимастера, который вернулся из вызова animaster)-->
<!--        - метод addMove должен добавлять в поле this._steps новый шаг анимации.-->
<!--        Структуру, в которой будешь хранить каждый шаг, придумай сам.-->
<!--        Каждый шаг должен содержать следующую информацию:-->
<!--        - название элементарной операции (move, fadeIn)-->
<!--        - продолжительность шага в миллисекундах-->
<!--        - дополнительные параметры (смещение для move, соотношение для scale)-->
<!--        - метод play должен принимать элемент, который будем анимировать, в качестве аргумента-->
<!--        - метод play должен выполнять по очереди все шаги анимации, которые лежат в массиве this._steps,-->
<!--        применяя их к переданному ему элементу.-->

<!--        8. Сделай так, чтобы метод move работал на написанных на предыдущем шаге методах.-->

<!--        9. Сделай по аналогии с методом addMove методы addScale, addFadeIn и addFadeOut.-->
<!--        Перепиши соответствующие анимации, чтобы они переиспользовали эти методы.-->

<!--        10. Теперь у тебя должно быть возможным такое использование:-->



<!--        11. Перепиши сложные анимации moveAndHide, showAndHide и heartBeating на использование новых методов add... и play.-->
<!--        Чтобы сделать showAndHide, добавь метод addDelay, добавляющий шаг,-->
<!--        в котором ничего не происходит в течение заданного времени.-->
<!--        Чтобы сделать heartBeating, добавь в play в аргументы флаг cycled,-->
<!--        означающий, что шаги анимации надо повторять бесконечно.-->

<!--        12. Метод play должен возвращать объект с методом stop (применяется для heartBeating) и reset.-->
<!--        Метод reset должен возвращать элемент в исходное состояние (то, которое было до анимации):-->
<!--        - если элемент был скрыт, то скрыть его-->
<!--        - если был показан, то показать-->
<!--        - если элемент был сдвинут или его размер изменен, то вернуть в исходное состояние-->
<!--        Для этого воспользуйся функциями отмены элементарных операций.-->




    </markdown>
    <exercise.universal exerciseDirName="src/08_animaster" noStudentZip="true">
        <checkForPlagiarism>false</checkForPlagiarism>
        <hideSolutions>true</hideSolutions>
        <hideExpectedOutput>true</hideExpectedOutput>
        <userCodeFile>task.js</userCodeFile>
        <includePathForChecker>../TestsRunner</includePathForChecker>
        <dockerImageName>js-sandbox</dockerImageName>
        <run>node docker-test-runner.mjs</run>
        <region>Task</region>
    </exercise.universal>
</slide.exercise>
