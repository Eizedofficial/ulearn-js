<?xml version='1.0' encoding='UTF-8'?>
<slide xmlns="https://ulearn.me/schema/v2" title="Преобразование типов" id="793c99e8-19c3-4914-8ab9-126470db4e15">
  <markdown>
    # Преобразование типов

Уверены, многие из вас видели мемы про систему типов в JavaScript:

![best-js-meme-to-date-2.png](src/meme.png)

С первого взгляда выглядит страшно, но давайте попробуем разобраться.

Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу.

Например, `alert` автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.

## Строковое преобразование

Строковое преобразование происходит, когда требуется представление чего-либо в виде строки.

Например, `alert(value)` преобразует значение к строке.

Также мы можем использовать функцию `String(value)`, чтобы преобразовать значение к строке:

<code>
let value = true;
alert(typeof value); // boolean

*value = String(value); // теперь value это строка "true"
alert(typeof value); // string*
</code>

Преобразование происходит очевидным образом. `false` становится `"false"`, `null` становится `"null"` и т.п.

## Численное преобразование

Численное преобразование происходит в математических функциях и выражениях.

Например, когда операция деления `/` применяется не к числу:

<code>
alert( "6" / "2" ); // 3, строки преобразуются в числа
</code>

Мы можем использовать функцию `Number(value)`, чтобы явно преобразовать `value` к числу:

<code>
let str = "123";
alert(typeof str); // string

let num = Number(str); // становится числом 123

alert(typeof num); // number
</code>

Явное преобразование часто применяется, когда мы ожидаем 
получить число из строкового контекста, например из текстовых полей 
форм.

Если строка не может быть явно приведена к числу, то результатом преобразования будет `NaN`. Например:

<code>
let age = Number("Любая строка вместо числа");

alert(age); // NaN, преобразование не удалось
</code>

Правила численного преобразования:

Примеры:

<code>
alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (ошибка чтения числа на месте символа "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0
</code>

Учтите, что `null` и `undefined` ведут себя по-разному. Так, `null` становится нулём, тогда как `undefined` приводится к `NaN`.

Большинство математических операторов также производит данное преобразование, как мы увидим в следующей главе.

## Логическое преобразование

Логическое преобразование самое простое.

Происходит в логических операциях (позже мы познакомимся с условными 
проверками и подобными конструкциями), но также может быть выполнено 
явно с помощью функции `Boolean(value)`.

Правило преобразования:

- Значения, которые интуитивно «пустые», вроде `0`, пустой строки, `null`, `undefined` и `NaN`, становятся `false`.
- Все остальные значения становятся `true`.

Например:

<code>
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("Привет!") ); // true
alert( Boolean("") ); // false
</code>

Заметим, что строчка с нулём `"0"` — это `true`

Некоторые языки (к примеру, PHP) воспринимают строку `"0"` как `false`. Но в JavaScript, если строка не пустая, то она всегда `true`.

<code>
alert( Boolean("0") ); // true
alert( Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)
</code>

## Сложение строк при помощи бинарного +

Давайте рассмотрим специальные возможности операторов JavaScript, которые выходят за рамки школьной арифметики.

Обычно при помощи плюса `'+'` складывают числа.

Но если бинарный оператор `'+'` применить к строкам, то он их объединяет в одну:

<code>
let s = "моя" + "строка";
alert(s); // моястрока
</code>

Обратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку.

Например:

<code>
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
</code>

Как видите, не важно, первый или второй операнд является строкой.

Вот пример посложнее:

<code>
alert(2 + 2 + '1' ); // будет "41", а не "221"
</code>

Здесь операторы работают один за другим. Первый `+` складывает два числа и возвращает `4`, затем следующий `+` объединяет результат со строкой, производя действие `4 + '1' = '41'`.

Сложение и преобразование строк — это особенность бинарного плюса `+`. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.

Например, вычитание и деление:

<code>
alert( 6 - '2' ); // 4, '2' приводится к числу
alert( '6' / '2' ); // 3, оба операнда приводятся к числам
</code>

## Приведение к числу, унарный +

Плюс `+` существует в двух формах: бинарной, которую мы использовали выше, и унарной.

Унарный, то есть применённый к одному значению, плюс `+` ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.

Например:

<code>
// Не влияет на числа
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

*// Преобразует не числа в числа
alert( +true ); // 1
alert( +"" );   // 0*
</code>

На самом деле это то же самое, что и `Number(...)`, только короче.

Необходимость преобразовывать строки в числа возникает очень часто. 
Например, обычно значения полей HTML-формы — это строки. А что, если их 
нужно, к примеру, сложить?

Бинарный плюс сложит их как строки:

<code>
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", так как бинарный плюс объединяет строки
</code>

Поэтому используем унарный плюс, чтобы преобразовать к числу:

<code>
let apples = "2";
let oranges = "3";

*// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5*// более длинный вариант
// alert( Number(apples) + Number(oranges) ); // 5
</code>

С точки зрения математика, такое изобилие плюсов выглядит
 странным. Но с точки зрения программиста тут нет ничего особенного: 
сначала выполнятся унарные плюсы, которые приведут строки к числам, а 
затем бинарный `'+'` их сложит.

Почему унарные плюсы выполнились до бинарного сложения? Как мы сейчас увидим, дело в их приоритете.

## [Итого](https://learn.javascript.ru/type-conversions#itogo)

Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.

**`Строковое`** – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью `String(value)`. Для примитивных значений работает очевидным образом.

**`Численное`** – Происходит в математических операциях. Может быть вызвано с помощью `Number(value)`.

Преобразование подчиняется правилам:

**`Логическое`** – Происходит в логических операциях. Может быть вызвано с помощью `Boolean(value)`.

Подчиняется правилам:

Большую часть из этих правил легко понять и запомнить. Особые случаи, в которых часто допускаются ошибки:

- `undefined` при численном преобразовании становится `NaN`, не `0`.
- `"0"` и строки из одних пробелов типа `" "` при логическом преобразовании всегда `true`.

| --- | --- |

| --- | --- |

| --- | --- |
  </markdown>
</slide>
